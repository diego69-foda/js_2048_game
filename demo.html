<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2048 - Demo</title>
    <style>
        body {
            margin: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            background: #fbf8ef;
            font-family: sans-serif;
            font-size: 24px;
            font-weight: 900;
        }

        .field-cell {
            background: #d6cdc4;
            width: 75px;
            height: 75px;
            border-radius: 5px;
            color: #776e65;
            box-sizing: border-box;
            text-align: center;
            vertical-align: middle;
            user-select: none;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            font-weight: bold;
        }

        .field-cell--2 { background: #eee4da; }
        .field-cell--4 { background: #ede0c8; }
        .field-cell--8 { background: #f2b179; color: #f9f6f2; }
        .field-cell--16 { background: #f59563; color: #f9f6f2; }
        .field-cell--32 { background: #f67c5f; color: #f9f6f2; }
        .field-cell--64 { background: #f65e3b; color: #f9f6f2; }
        .field-cell--128 { background: #edcf72; color: #f9f6f2; }
        .field-cell--256 { background: #edcc61; color: #f9f6f2; }
        .field-cell--512 { background: #edc850; color: #f9f6f2; }
        .field-cell--1024 { background: #edc53f; color: #f9f6f2; }
        .field-cell--2048 { background: #edc22e; color: #f9f6f2; }

        .game-field {
            background: #bbada0;
            border-spacing: 10px;
            border-radius: 5px;
        }

        .game-header {
            display: flex;
            width: 100%;
            justify-content: space-between;
            margin-bottom: 24px;
            padding: 10px;
            box-sizing: border-box;
        }

        h1 {
            background: #edc22e;
            color: #f9f6f2;
            width: 75px;
            height: 75px;
            font-size: 24px;
            border-radius: 5px;
            display: flex;
            align-items: center;
            justify-content: center;
            box-sizing: border-box;
            margin: 0;
        }

        .info {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: #d6cdc4;
            width: 75px;
            height: 75px;
            border-radius: 5px;
            color: #776e65;
            box-sizing: border-box;
            font-size: 16px;
            margin: 0 8px 0 0;
        }

        .controls {
            display: flex;
        }

        .button {
            border: none;
            border-radius: 5px;
            cursor: pointer;
            color: #f9f6f2;
            font-family: sans-serif;
            font-weight: 700;
            font-size: 16px;
            width: 75px;
            height: 75px;
            transition: 0.25s ease background;
        }

        .start {
            background: #1dae28;
            font-size: 20px;
        }

        .start:hover {
            background: #179921;
        }

        .restart {
            background: #f1b2b2;
        }

        .restart:hover {
            background: #f87474;
        }

        .message {
            box-sizing: border-box;
            width: 100%;
            background: #d6cdc4;
            color: #776e65;
            padding: 10px;
            text-align: center;
            border-radius: 5px;
            font-size: 20px;
        }

        .hidden {
            display: none;
        }

        .container {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 350px;
        }

        .message-win {
            background: #edc22e;
            color: #f9f6f2;
        }

        .message-container {
            width: 100%;
            height: 150px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="game-header">
            <h1>2048</h1>
            <div class="controls">
                <p class="info">
                    Score:
                    <span class="game-score">0</span>
                </p>
                <button class="button start">Start</button>
            </div>
        </div>

        <table class="game-field">
            <tbody>
                <tr class="field-row">
                    <td class="field-cell"></td>
                    <td class="field-cell"></td>
                    <td class="field-cell"></td>
                    <td class="field-cell"></td>
                </tr>
                <tr class="field-row">
                    <td class="field-cell"></td>
                    <td class="field-cell"></td>
                    <td class="field-cell"></td>
                    <td class="field-cell"></td>
                </tr>
                <tr class="field-row">
                    <td class="field-cell"></td>
                    <td class="field-cell"></td>
                    <td class="field-cell"></td>
                    <td class="field-cell"></td>
                </tr>
                <tr class="field-row">
                    <td class="field-cell"></td>
                    <td class="field-cell"></td>
                    <td class="field-cell"></td>
                    <td class="field-cell"></td>
                </tr>
            </tbody>
        </table>

        <div class="message-container">
            <p class="message message-lose hidden">Você perdeu! Reiniciar o jogo?</p>
            <p class="message message-win hidden">Vencedor! Parabéns! Você conseguiu!</p>
            <p class="message message-start">
                Pressione "Start" para começar o jogo. Boa sorte!
            </p>
        </div>
    </div>

    <script>
        'use strict';

        // Classe Game implementada diretamente no arquivo
        class Game {
            constructor(initialState) {
                this.board = initialState || [
                    [0, 0, 0, 0],
                    [0, 0, 0, 0],
                    [0, 0, 0, 0],
                    [0, 0, 0, 0]
                ];
                this.score = 0;
                this.status = 'idle'; // 'idle', 'playing', 'win', 'lose'
                this.size = 4;
            }

            generateRandomTile() {
                const emptyCells = [];
                
                for (let i = 0; i < this.size; i++) {
                    for (let j = 0; j < this.size; j++) {
                        if (this.board[i][j] === 0) {
                            emptyCells.push({ row: i, col: j });
                        }
                    }
                }
                
                if (emptyCells.length > 0) {
                    const randomCell = emptyCells[Math.floor(Math.random() * emptyCells.length)];
                    const value = Math.random() < 0.9 ? 2 : 4; // 90% chance de 2, 10% chance de 4
                    this.board[randomCell.row][randomCell.col] = value;
                }
            }

            moveLeft() {
                if (this.status !== 'playing') return false;
                
                const originalBoard = JSON.stringify(this.board);
                
                for (let i = 0; i < this.size; i++) {
                    this.board[i] = this.mergeLine(this.board[i]);
                }
                
                const changed = JSON.stringify(this.board) !== originalBoard;
                if (changed) {
                    this.generateRandomTile();
                    this.checkGameStatus();
                }
                
                return changed;
            }

            moveRight() {
                if (this.status !== 'playing') return false;
                
                const originalBoard = JSON.stringify(this.board);
                
                for (let i = 0; i < this.size; i++) {
                    const reversed = this.board[i].reverse();
                    const merged = this.mergeLine(reversed);
                    this.board[i] = merged.reverse();
                }
                
                const changed = JSON.stringify(this.board) !== originalBoard;
                if (changed) {
                    this.generateRandomTile();
                    this.checkGameStatus();
                }
                
                return changed;
            }

            moveUp() {
                if (this.status !== 'playing') return false;
                
                const originalBoard = JSON.stringify(this.board);
                
                for (let j = 0; j < this.size; j++) {
                    const column = [];
                    for (let i = 0; i < this.size; i++) {
                        column.push(this.board[i][j]);
                    }
                    
                    const merged = this.mergeLine(column);
                    
                    for (let i = 0; i < this.size; i++) {
                        this.board[i][j] = merged[i];
                    }
                }
                
                const changed = JSON.stringify(this.board) !== originalBoard;
                if (changed) {
                    this.generateRandomTile();
                    this.checkGameStatus();
                }
                
                return changed;
            }

            moveDown() {
                if (this.status !== 'playing') return false;
                
                const originalBoard = JSON.stringify(this.board);
                
                for (let j = 0; j < this.size; j++) {
                    const column = [];
                    for (let i = 0; i < this.size; i++) {
                        column.push(this.board[i][j]);
                    }
                    
                    const reversed = column.reverse();
                    const merged = this.mergeLine(reversed);
                    const finalColumn = merged.reverse();
                    
                    for (let i = 0; i < this.size; i++) {
                        this.board[i][j] = finalColumn[i];
                    }
                }
                
                const changed = JSON.stringify(this.board) !== originalBoard;
                if (changed) {
                    this.generateRandomTile();
                    this.checkGameStatus();
                }
                
                return changed;
            }

            mergeLine(line) {
                // Remove zeros
                const filtered = line.filter(cell => cell !== 0);
                
                // Mescla números iguais adjacentes
                for (let i = 0; i < filtered.length - 1; i++) {
                    if (filtered[i] === filtered[i + 1]) {
                        filtered[i] *= 2;
                        this.score += filtered[i];
                        filtered.splice(i + 1, 1);
                    }
                }
                
                // Adiciona zeros no final
                while (filtered.length < this.size) {
                    filtered.push(0);
                }
                
                return filtered;
            }

            hasValidMoves() {
                // Verifica se há células vazias
                for (let i = 0; i < this.size; i++) {
                    for (let j = 0; j < this.size; j++) {
                        if (this.board[i][j] === 0) return true;
                    }
                }
                
                // Verifica se há possibilidade de mesclar
                for (let i = 0; i < this.size; i++) {
                    for (let j = 0; j < this.size; j++) {
                        const current = this.board[i][j];
                        
                        // Verifica direita
                        if (j < this.size - 1 && this.board[i][j + 1] === current) return true;
                        // Verifica baixo
                        if (i < this.size - 1 && this.board[i + 1][j] === current) return true;
                    }
                }
                
                return false;
            }

            hasWon() {
                for (let i = 0; i < this.size; i++) {
                    for (let j = 0; j < this.size; j++) {
                        if (this.board[i][j] === 2048) return true;
                    }
                }
                return false;
            }

            checkGameStatus() {
                if (this.hasWon()) {
                    this.status = 'win';
                } else if (!this.hasValidMoves()) {
                    this.status = 'lose';
                }
            }

            getScore() {
                return this.score;
            }

            getState() {
                return this.board.map(row => [...row]);
            }

            getStatus() {
                return this.status;
            }

            start() {
                this.status = 'playing';
                this.score = 0;
                this.board = [
                    [0, 0, 0, 0],
                    [0, 0, 0, 0],
                    [0, 0, 0, 0],
                    [0, 0, 0, 0]
                ];
                
                // Gera duas peças iniciais
                this.generateRandomTile();
                this.generateRandomTile();
            }

            restart() {
                this.start();
            }
        }

        // Cria uma instância do jogo
        const game = new Game();

        // Elementos da interface
        const gameField = document.querySelector('.game-field');
        const gameScore = document.querySelector('.game-score');
        const startButton = document.querySelector('.button.start');
        const messageContainer = document.querySelector('.message-container');
        const messageStart = document.querySelector('.message-start');
        const messageWin = document.querySelector('.message-win');
        const messageLose = document.querySelector('.message-lose');

        // Função para atualizar a interface do jogo
        function updateGameInterface() {
            const state = game.getState();
            const score = game.getScore();
            const status = game.getStatus();
            
            // Atualiza o score
            gameScore.textContent = score;
            
            // Atualiza o tabuleiro
            const cells = gameField.querySelectorAll('.field-cell');
            cells.forEach((cell, index) => {
                const row = Math.floor(index / 4);
                const col = index % 4;
                const value = state[row][col];
                
                // Remove todas as classes de valor
                cell.className = 'field-cell';
                
                if (value !== 0) {
                    cell.textContent = value;
                    cell.classList.add(`field-cell--${value}`);
                } else {
                    cell.textContent = '';
                }
            });
            
            // Atualiza as mensagens baseado no status
            messageStart.classList.add('hidden');
            messageWin.classList.add('hidden');
            messageLose.classList.add('hidden');
            
            switch (status) {
                case 'idle':
                    messageStart.classList.remove('hidden');
                    break;
                case 'win':
                    messageWin.classList.remove('hidden');
                    break;
                case 'lose':
                    messageLose.classList.remove('hidden');
                    break;
            }
            
            // Atualiza o botão
            if (status === 'playing') {
                startButton.textContent = 'Restart';
                startButton.classList.remove('start');
                startButton.classList.add('restart');
            } else {
                startButton.textContent = 'Start';
                startButton.classList.remove('restart');
                startButton.classList.add('start');
            }
        }

        // Função para lidar com movimentos do teclado
        function handleKeydown(event) {
            if (game.getStatus() !== 'playing') return;
            
            let moved = false;
            
            switch (event.key) {
                case 'ArrowLeft':
                    moved = game.moveLeft();
                    break;
                case 'ArrowRight':
                    moved = game.moveRight();
                    break;
                case 'ArrowUp':
                    moved = game.moveUp();
                    break;
                case 'ArrowDown':
                    moved = game.moveDown();
                    break;
                default:
                    return;
            }
            
            if (moved) {
                updateGameInterface();
            }
        }

        // Função para lidar com cliques no botão
        function handleButtonClick() {
            const status = game.getStatus();
            
            if (status === 'idle' || status === 'win' || status === 'lose') {
                game.start();
            } else {
                game.restart();
            }
            
            updateGameInterface();
        }

        // Função para lidar com toques em dispositivos móveis
        let touchStartX = 0;
        let touchStartY = 0;

        function handleTouchStart(event) {
            touchStartX = event.touches[0].clientX;
            touchStartY = event.touches[0].clientY;
        }

        function handleTouchEnd(event) {
            if (game.getStatus() !== 'playing') return;
            
            const touchEndX = event.changedTouches[0].clientX;
            const touchEndY = event.changedTouches[0].clientY;
            
            const deltaX = touchEndX - touchStartX;
            const deltaY = touchEndY - touchStartY;
            
            const minSwipeDistance = 30;
            let moved = false;
            
            if (Math.abs(deltaX) > Math.abs(deltaY)) {
                // Movimento horizontal
                if (Math.abs(deltaX) > minSwipeDistance) {
                    if (deltaX > 0) {
                        moved = game.moveRight();
                    } else {
                        moved = game.moveLeft();
                    }
                }
            } else {
                // Movimento vertical
                if (Math.abs(deltaY) > minSwipeDistance) {
                    if (deltaY > 0) {
                        moved = game.moveDown();
                    } else {
                        moved = game.moveUp();
                    }
                }
            }
            
            if (moved) {
                updateGameInterface();
            }
        }

        // Adiciona event listeners
        document.addEventListener('keydown', handleKeydown);
        startButton.addEventListener('click', handleButtonClick);

        // Suporte para dispositivos móveis
        gameField.addEventListener('touchstart', handleTouchStart, { passive: true });
        gameField.addEventListener('touchend', handleTouchEnd, { passive: true });

        // Inicializa a interface
        updateGameInterface();

        // Previne o comportamento padrão de scroll em dispositivos móveis
        gameField.addEventListener('touchmove', (event) => {
            event.preventDefault();
        }, { passive: false });
    </script>
</body>
</html>
